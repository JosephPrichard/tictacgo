// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const getGame = `-- name: GetGame :one
SELECT 
    g.id,
    g.x_player,
    g.o_player,
    g.board_state,
    g.x_turn,
    g.updated_on,
    g.started_on,
    g.result,
    a1.username as x_player_name,
    a2.username as o_player_name
FROM games g
LEFT JOIN player_accounts a1 ON a1.id = g.x_player
LEFT JOIN player_accounts a2 ON a2.id = g.o_player
WHERE g.id = $1
`

type GetGameRow struct {
	ID          int64
	XPlayer     int64
	OPlayer     pgtype.Int8
	BoardState  int32
	XTurn       pgtype.Bool
	UpdatedOn   pgtype.Timestamp
	StartedOn   pgtype.Timestamp
	Result      int32
	XPlayerName pgtype.Text
	OPlayerName pgtype.Text
}

func (q *Queries) GetGame(ctx context.Context, id int64) (GetGameRow, error) {
	row := q.db.QueryRow(ctx, getGame, id)
	var i GetGameRow
	err := row.Scan(
		&i.ID,
		&i.XPlayer,
		&i.OPlayer,
		&i.BoardState,
		&i.XTurn,
		&i.UpdatedOn,
		&i.StartedOn,
		&i.Result,
		&i.XPlayerName,
		&i.OPlayerName,
	)
	return i, err
}

const getGames = `-- name: GetGames :many
SELECT
    g.id,
    g.x_player,
    g.o_player,
    g.board_state,
    g.x_turn,
    g.updated_on,
    g.started_on,
    g.result,
    a1.username as x_player_name,
    a2.username as o_player_name
FROM games g
LEFT JOIN player_accounts a1 ON a1.id = g.x_player
LEFT JOIN player_accounts a2 ON a2.id = g.o_player
WHERE g.id > $1 AND 
    (g.x_player = COALESCE($2, g.x_player) OR 
        g.o_player = COALESCE($3, g.o_player)) AND
    result != 0
ORDER BY g.id ASC LIMIT $4
`

type GetGamesParams struct {
	ID      int64
	XPlayer pgtype.Int8
	OPlayer pgtype.Int8
	Limit   int32
}

type GetGamesRow struct {
	ID          int64
	XPlayer     int64
	OPlayer     pgtype.Int8
	BoardState  int32
	XTurn       pgtype.Bool
	UpdatedOn   pgtype.Timestamp
	StartedOn   pgtype.Timestamp
	Result      int32
	XPlayerName pgtype.Text
	OPlayerName pgtype.Text
}

func (q *Queries) GetGames(ctx context.Context, arg GetGamesParams) ([]GetGamesRow, error) {
	rows, err := q.db.Query(ctx, getGames,
		arg.ID,
		arg.XPlayer,
		arg.OPlayer,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGamesRow
	for rows.Next() {
		var i GetGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.XPlayer,
			&i.OPlayer,
			&i.BoardState,
			&i.XTurn,
			&i.UpdatedOn,
			&i.StartedOn,
			&i.Result,
			&i.XPlayerName,
			&i.OPlayerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastStep = `-- name: GetLastStep :one
SELECT game_id, ord, move_row, move_col, board, x_turn, result FROM game_steps
WHERE game_id = $1
ORDER BY ord DESC LIMIT 1
`

func (q *Queries) GetLastStep(ctx context.Context, gameID int64) (GameStep, error) {
	row := q.db.QueryRow(ctx, getLastStep, gameID)
	var i GameStep
	err := row.Scan(
		&i.GameID,
		&i.Ord,
		&i.MoveRow,
		&i.MoveCol,
		&i.Board,
		&i.XTurn,
		&i.Result,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, username FROM player_accounts WHERE id = $1
`

type GetPlayerRow struct {
	ID       int64
	Username string
}

func (q *Queries) GetPlayer(ctx context.Context, id int64) (GetPlayerRow, error) {
	row := q.db.QueryRow(ctx, getPlayer, id)
	var i GetPlayerRow
	err := row.Scan(&i.ID, &i.Username)
	return i, err
}

const getPlayers = `-- name: GetPlayers :many
SELECT id, username FROM player_accounts
WHERE id > $1
ORDER BY id ASC LIMIT $2
`

type GetPlayersParams struct {
	ID    int64
	Limit int32
}

type GetPlayersRow struct {
	ID       int64
	Username string
}

func (q *Queries) GetPlayers(ctx context.Context, arg GetPlayersParams) ([]GetPlayersRow, error) {
	rows, err := q.db.Query(ctx, getPlayers, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayersRow
	for rows.Next() {
		var i GetPlayersRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT a.id, a.username FROM player_sessions s
INNER JOIN player_accounts a ON a.id = s.player_id
WHERE token = $1
`

type GetSessionRow struct {
	ID       int64
	Username string
}

func (q *Queries) GetSession(ctx context.Context, token string) (GetSessionRow, error) {
	row := q.db.QueryRow(ctx, getSession, token)
	var i GetSessionRow
	err := row.Scan(&i.ID, &i.Username)
	return i, err
}

const getSteps = `-- name: GetSteps :many
SELECT game_id, ord, move_row, move_col, board, x_turn, result FROM game_steps 
WHERE game_id = ANY ($1::BIGINT[])
ORDER BY game_id, ord
`

func (q *Queries) GetSteps(ctx context.Context, gameids []int64) ([]GameStep, error) {
	rows, err := q.db.Query(ctx, getSteps, gameids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameStep
	for rows.Next() {
		var i GameStep
		if err := rows.Scan(
			&i.GameID,
			&i.Ord,
			&i.MoveRow,
			&i.MoveCol,
			&i.Board,
			&i.XTurn,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGame = `-- name: InsertGame :one
INSERT INTO 
games (x_player, o_player, board_state, x_turn, updated_on, started_on) 
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type InsertGameParams struct {
	XPlayer    int64
	OPlayer    pgtype.Int8
	BoardState int32
	XTurn      pgtype.Bool
	UpdatedOn  pgtype.Timestamp
	StartedOn  pgtype.Timestamp
}

func (q *Queries) InsertGame(ctx context.Context, arg InsertGameParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertGame,
		arg.XPlayer,
		arg.OPlayer,
		arg.BoardState,
		arg.XTurn,
		arg.UpdatedOn,
		arg.StartedOn,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertPlayer = `-- name: InsertPlayer :one
INSERT INTO player_accounts (username, passwd, salt)
VALUES ($1, $2, $3)
RETURNING id, username
`

type InsertPlayerParams struct {
	Username string
	Passwd   string
	Salt     string
}

type InsertPlayerRow struct {
	ID       int64
	Username string
}

func (q *Queries) InsertPlayer(ctx context.Context, arg InsertPlayerParams) (InsertPlayerRow, error) {
	row := q.db.QueryRow(ctx, insertPlayer, arg.Username, arg.Passwd, arg.Salt)
	var i InsertPlayerRow
	err := row.Scan(&i.ID, &i.Username)
	return i, err
}

const insertSession = `-- name: InsertSession :execresult
INSERT INTO player_sessions (token, player_id)
VALUES ($1, $2)
`

type InsertSessionParams struct {
	Token    string
	PlayerID int64
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertSession, arg.Token, arg.PlayerID)
}

const insertStep = `-- name: InsertStep :execresult
INSERT INTO game_steps (game_id, ord, move_row, move_col, board, x_turn) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertStepParams struct {
	GameID  int64
	Ord     int32
	MoveRow int32
	MoveCol int32
	Board   int32
	XTurn   bool
}

func (q *Queries) InsertStep(ctx context.Context, arg InsertStepParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertStep,
		arg.GameID,
		arg.Ord,
		arg.MoveRow,
		arg.MoveCol,
		arg.Board,
		arg.XTurn,
	)
}

const updateGame = `-- name: UpdateGame :execresult
UPDATE games 
SET board_state = $1, x_turn = $2, updated_on = $3, result = $4
WHERE id = $5
`

type UpdateGameParams struct {
	BoardState int32
	XTurn      pgtype.Bool
	UpdatedOn  pgtype.Timestamp
	Result     int32
	ID         int64
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateGame,
		arg.BoardState,
		arg.XTurn,
		arg.UpdatedOn,
		arg.Result,
		arg.ID,
	)
}

const verifyPlayer = `-- name: VerifyPlayer :many
SELECT id, username FROM player_accounts WHERE username = $1 AND passwd = $2
`

type VerifyPlayerParams struct {
	Username string
	Passwd   string
}

type VerifyPlayerRow struct {
	ID       int64
	Username string
}

func (q *Queries) VerifyPlayer(ctx context.Context, arg VerifyPlayerParams) ([]VerifyPlayerRow, error) {
	rows, err := q.db.Query(ctx, verifyPlayer, arg.Username, arg.Passwd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerifyPlayerRow
	for rows.Next() {
		var i VerifyPlayerRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
